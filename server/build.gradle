import groovy.io.FileType
import java.util.stream.Collectors
import org.zeroturnaround.zip.commons.FileUtils

plugins {
	id 'org.springframework.boot'
	id 'war'
}

springBoot {
	mainClass = "com.cezarykluczynski.stapi.server.Application"
}

dependencies {
	implementation project(':util'), project(':contract'), project(':model'), project(':etl'), project(':client')
	implementation group: 'org.projectlombok', name: 'lombok', version: lombokVersion
	implementation group: 'org.springframework.boot', name: 'spring-boot-starter-tomcat', version: springBootVersion
	implementation group: 'org.springframework.boot', name: 'spring-boot-starter-web-services', version: springBootVersion
	implementation group: 'org.springframework.boot', name: 'spring-boot-starter-batch', version: springBootVersion
	implementation group: 'org.springframework.data', name: 'spring-data-jpa', version: springBootVersion
	implementation group: 'org.hibernate', name: 'hibernate-core', version: hibernateVersion
	implementation group: 'org.liquibase', name: 'liquibase-core', version: liquibaseVersion
	implementation group: 'org.kohsuke', name: 'github-api', version: '1.313'

	// CXF
	implementation group: 'org.apache.cxf', name: 'cxf-spring-boot-starter-jaxws', version: apacheCxfVersion
	implementation group: 'org.apache.cxf', name: 'cxf-spring-boot-starter-jaxrs', version: apacheCxfVersion
	implementation group: 'org.apache.cxf', name: 'cxf-rt-rs-security-cors', version: apacheCxfVersion
	implementation group: 'com.fasterxml.jackson.jaxrs', name: 'jackson-jaxrs-json-provider', version: jacksonVersion
	implementation group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-jsr310', version: jacksonVersion

	// Utils
	implementation "org.mapstruct:mapstruct:$mapstructVersion"
	annotationProcessor "org.mapstruct:mapstruct-processor:$mapstructVersion"
	implementation group: 'org.zeroturnaround', name: 'zt-zip', version: ztZipVersion
	implementation group: 'org.aspectj', name: 'aspectjweaver', version: '1.9.7'

	// Other
	implementation group: 'javax.servlet', name: 'jstl', version: '1.2'
	implementation group: 'javax.json', name: 'javax.json-api', version: '1.0'
	implementation group: 'org.glassfish', name: 'javax.json', version: '1.0.4'

	testImplementation project(':util').sourceSets.test.output
}

apply from: 'codeGen.gradle'

configurations.implementation.exclude group: 'io.swagger'

task copyDocs(type: CopyDocs) {}
task copyResources(type: CopyResources) {}
task dockerize(type: Dockerize) {}
task npmBuild(type: NpmRunBuild) {}

copyDocs {
	dependsOn(npmBuild)
}
copyResources {
	dependsOn(copyDocs)
}

dockerize {
	dependsOn('bootWar')
}

class NpmRunBuild extends DefaultTask {

	@TaskAction
	def doExecute() {
		ProcessBuilder pb
		if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
			pb = new ProcessBuilder(['cmd', '/c', 'npm', 'run', 'install-build'])
		} else {
			pb = new ProcessBuilder(['npm', 'run', 'install-build'])
		}
		pb.directory(new File('./server/src/main/web'))
		pb.inheritIO()

		Process proc = pb.start()
		proc.waitFor()
	}
}

class CopyDocs extends DefaultTask {

	@TaskAction
	def copy() {
		def dir = new File('./contract/src/main/resources/v1/')
		dir.eachFileRecurse (FileType.FILES) { file ->
			File destination = new File('./server/build/resources/main/' + file.getPath().substring(2))
			destination.parentFile.mkdirs()
			FileUtils.copyFile(file, destination)
		}
	}

}

class CopyResources extends DefaultTask {

	@TaskAction
	def copy() {
		def dir = new File('./server/src/main/resources/')
		dir.eachFile (FileType.FILES) { file ->
			String extension = file.getAbsolutePath().split('\\.').last()
			if (['xml', 'txt', 'properties'].contains(extension) && !file.getName().contains('stapi-custom')) {
				File destination = new File('./server/build/resources/main/' + file.getName())
				destination.parentFile.mkdirs()
				destination.createNewFile()
				FileUtils.copyFile(file, destination)
			}
		}
		File docker = new File('./server/build/resources/main/application-docker.properties')
		File stapiCustom = new File('./server/build/resources/main/application-stapi-custom.properties')
		try {
			FileUtils.forceDelete(stapiCustom)
		} catch (Exception ignore) {
		}
		FileUtils.moveFile(docker, stapiCustom)
	}

}

class Dockerize extends DefaultTask {

	private String version

	@Option(option = "version", description = "Data version which should be downloaded")
	void setVersion(String version) {
		this.version = version
	}

	@Input
	String getVersion() {
		return version
	}

	@TaskAction
	def dockerize() {
		String dataFileUrl = "https://s3.us-east-2.amazonaws.com/static.stapi/db_dumps/${this.version}/postgres.sql"
		String localDirPath = "data/"
		new File(localDirPath).mkdir()
		String localPath = "data/postgres.sql"
		File localFile = new File(localPath)
		if (localFile.exists()) {
			localFile.delete()
		}
		localFile.text = ''
		ant.get(src: dataFileUrl, dest: localFile.absolutePath)
		logger.info("Downloaded data version ${this.version} from S3 to ${localPath}.")

		ProcessBuilder pb
		if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
			pb = new ProcessBuilder(['cmd', '/c', 'docker', 'build', '.', '--no-cache', '--build-arg', 'STAPI_DATA_VERSION=' + this.version, '-t', 'cezarykluczynski/stapi:' + this.version, '-t', 'cezarykluczynski/stapi:latest'])
		} else {
			pb = new ProcessBuilder(['docker', 'build', '.', '--no-cache', '--build-arg', 'STAPI_DATA_VERSION=' + this.version, '-t', 'cezarykluczynski/stapi:' + this.version, '-t', 'cezarykluczynski/stapi:latest'])
		}
		pb.directory(new File('.'))
		File buildLog = new File('./docker/build.log')
		pb.redirectOutput(buildLog)
		pb.redirectError(buildLog)
		Process proc = pb.start()
		proc.waitFor()
		if (proc.exitValue() != 0) {
			throw new RuntimeException('Could not build docker image, details in docker/build.log')
		}
	}

}

bootWar {
	archiveFileName = 'stapi.war'
	dependsOn(copyResources)
}

