import groovy.io.FileType
import org.zeroturnaround.zip.commons.FileUtils

import java.util.stream.Collectors

plugins {
	id 'net.ltgt.apt' version '0.8'
}

apply plugin: 'spring-boot'
apply plugin: 'war'

springBoot {
	mainClass = "com.cezarykluczynski.stapi.server.Application"
}

dependencies {
	compile project(':etl'), project(':client')
	compile group: 'org.springframework.boot', name: 'spring-boot-starter-tomcat', version: springBootVersion
	compile group: 'org.springframework.boot', name: 'spring-boot-starter-web-services', version: springBootVersion
	compile group: 'org.liquibase', name: 'liquibase-core', version: '3.5.3'
	compile group: 'com.oracle', name: 'ojdbc6', version: '11.2.0.4.0-atlassian-hosted'
	compile group: 'org.kohsuke', name: 'github-api', version: '1.82'

	// CXF
	compile group: 'org.apache.cxf', name: 'cxf-spring-boot-starter-jaxws', version: '3.1.7'
	compile group: 'org.apache.cxf', name: 'cxf-spring-boot-starter-jaxrs', version: '3.1.7'
	compile group: 'org.apache.cxf', name: 'cxf-rt-rs-security-cors', version: '3.1.7'
	compile group: 'com.fasterxml.jackson.jaxrs', name: 'jackson-jaxrs-json-provider', version: '2.8.3'
	compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-jsr310', version: '2.8.3'

	// Utils
	compile group: 'joda-time', name: 'joda-time', version: '2.9.2'
	compile group: 'com.google.code.gson', name: 'gson', version: '2.10'
	compile 'org.mapstruct:mapstruct-jdk8:1.2.0.Beta2'
	apt 'org.mapstruct:mapstruct-processor:1.2.0.Beta2'
	compile group: 'org.zeroturnaround', name: 'zt-zip', version: '1.11'

	// Other
	compile group: 'javax.servlet', name: 'jstl', version: '1.2'
	compile group: 'commons-dbcp', name: 'commons-dbcp', version: '1.4'
	compile group: 'javax.json', name: 'javax.json-api', version: '1.0'
	compile group: 'org.glassfish', name: 'javax.json', version: '1.0.4'

	testCompile project(':util').sourceSets.test.output
}

apply from: 'codeGen.gradle'

configurations.compile.exclude group: 'io.swagger'

task copyDocs(type: CopyDocs) << {}
task copyResources(type: CopyResources) << {}
task dockerize(type: Dockerize) << {}
task npmBuild(type: NpmRunBuild) << {}

copyDocs {
	dependsOn(npmBuild)
}
copyResources {
	dependsOn(copyDocs)
}

dockerize {
	dependsOn('bootRepackage')
}

class NpmRunBuild extends DefaultTask {

	@TaskAction
	def doExecute() {
		ProcessBuilder pb
		if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
			pb = new ProcessBuilder(['cmd', '/c', 'npm', 'run', 'install-build'])
		} else {
			pb = new ProcessBuilder(['npm', 'run', 'install-build'])
		}
		pb.directory(new File('./server/src/main/web'))
		pb.inheritIO()

		Process proc = pb.start()
		proc.waitFor()
	}
}

class CopyDocs extends DefaultTask {

	@TaskAction
	def copy() {
		def dir = new File('./contract/src/main/resources/v1/')
		dir.eachFileRecurse (FileType.FILES) { file ->
			File destination = new File('./server/build/resources/main/' + file.getPath().substring(2))
			destination.parentFile.mkdirs()
			FileUtils.copyFile(file, destination)
		}
	}

}

class CopyResources extends DefaultTask {

	@TaskAction
	def copy() {
		def dir = new File('./server/src/main/resources/')
		dir.eachFile (FileType.FILES) { file ->
			String extension = file.getAbsolutePath().split('\\.').last()
			if (['xml', 'txt', 'properties'].contains(extension) && !file.getName().contains('stapi-custom')) {
				File destination = new File('./server/build/resources/main/' + file.getName())
				destination.parentFile.mkdirs()
				destination.createNewFile()
				FileUtils.copyFile(file, destination)
			}
		}
		File docker = new File('./server/build/resources/main/application-docker.properties')
		File stapiCustom = new File('./server/build/resources/main/application-stapi-custom.properties')
		try {
			FileUtils.forceDelete(stapiCustom)
		} catch (Exception ignore) {
		}
		FileUtils.moveFile(docker, stapiCustom)
	}

}

class Dockerize extends DefaultTask {

	private String version;

	@Option(option = "version", description = "Data version which should be downloaded")
	public void setVersion(String version) {
		this.version = version
	}

	@Input
	public String getVersion() {
		return version
	}

	@TaskAction
	def dockerize() {
		String dataFileUrl = "https://s3.us-east-2.amazonaws.com/static.stapi/db_dumps/${this.version}/postgres.sql"
		String localDirPath = "data/"
		new File(localDirPath).mkdir()
		String localPath = "data/postgres.sql"
		File localFile = new File(localPath)
		if (localFile.exists()) {
			localFile.delete()
		}
		localFile.text = ''
		ant.get(src: dataFileUrl, dest: localFile.absolutePath)
		logger.info("Downloaded data version ${this.version} from S3 to ${localPath}.")

		ProcessBuilder pb
		if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
			pb = new ProcessBuilder(['cmd', '/c', 'docker', 'build', '.', '--build-arg', 'STAPI_DATA_VERSION=' + this.version, '-t', 'cezarykluczynski/stapi:' + this.version, '-t', 'cezarykluczynski/stapi:latest'])
		} else {
			pb = new ProcessBuilder(['docker', 'build', '.', '--build-arg', 'STAPI_DATA_VERSION=' + this.version, '-t', 'cezarykluczynski/stapi:' + this.version, '-t', 'cezarykluczynski/stapi:latest'])
		}
		pb.directory(new File('.'))
		pb.inheritIO()

		Process proc = pb.start()
		proc.waitFor()
		if (proc.exitValue() != 0) {
			throw new RuntimeException(new BufferedReader(new InputStreamReader(proc.errorStream))
					.lines().collect(Collectors.joining("\n")))
		} else {
			new BufferedReader(new InputStreamReader(proc.inputStream))
					.lines().forEach { println(it) }
		}
	}

}

war {
	archiveName = 'stapi.war'
	dependsOn(copyResources)
}

